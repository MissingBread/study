# 微服务
## 微服务简介
### 构建单体应用模型
* 运用分层思想构建的应用程序，尽管有逻辑模块化架构，但是作为一个单体打包部署
* 如Java打包成war文件部署在tomcat或者是jetty之类的应用服务器上
* 这种方式的应用很常见，非常易于开发和测试，单体应用同样易于部署，自需要打包拷贝到服务器即可
* 还可以通过运行多个副本结合负载均衡器来扩展应用
* 在早期阶段，可以良好运作

### 走向单体地狱
* 单体应用有很大的局限性。项目随着时间的推移会变得越来越臃肿，小而简单的应用变成了庞大的单体，互相之间依赖错综复杂
* 单体应用过于复杂，可读性变差，修复bug和实现新功能变得非常困难而耗时
* 基本代码都难以理解，那么改变也不会变得正确，负反馈作用下，得到的将是一个巨大且不可思议的大泥球
* 服务越大，启动时间将越长，时间在等待中流失
* 在变更系统的时候，启动时间太长，而且变更产生的影响通常不明确，需要大量测试，因此持续部署几乎不可能
* 当不同模块存在资源需求冲突时，单体应用难以扩展（CPU密集和IO密集，必须一方做出妥协）
* 单体应用可靠性低，所有模块运行在同一进程中，任何一个模块的bug（如内存泄漏）会拖垮整个进程
* 单体应用使得采用新框架和语言变得困难
> 总结：一个成功的关键应用程序，已经发展成一个只有少数开发人员理解的巨大单体，它使用了过时，非生产性技术编写
，使得招聘变得困难，应用程序难以扩展，不可靠，因此敏捷开发和应用交付是不可能的。

### 微服务-解决复杂问题
* 将应用程序分解成一套较小的互连服务，一个服务通常实现了一组不同的特性或者功能。如订单管理，客户管理
* 一些微服务会暴露一个提供其他微服务或应用客户端消费的api，其他微服务可能实现了一个web UI，运行时，每个实例
通常是一个云虚拟主机或一个docker容器
* 将Web应用程序划分成了一组更简单的web应用程序
* 应用不能直接访问后端服务，应通过API网关通信，API网关负责负载均衡，缓存，访问控制，API计量和监控（如Nginx）
* 每个服务实例是一个docker容器，为了实现高可用，容器在多个虚拟机上运行
* 微服务的架构影响到了应用程序和数据库之间的关系
** 每一服务都应该有自己的数据库模式
** 这样做与企业级数据库数据模型的思想相背，且会造成数据冗余
** 但利大于弊，能够实现松耦合，且可以选用最适合应用的数据库
* 看起来微服务架构类似SOA（面向服务架构）

### 微服务的优点
* 解决了复杂的问题，强制一定程度的模块化，使得个体服务能被更快的开发，并更容易理解与维护
* 每个服务都可以由一个团队专注开发，可自由进行技术选型使用新技术，而且服务较小，用新技术重写旧服务变得可行
* 每个微服务独立部署，不需要协调部署本地变更到服务，使得持续部署成为可能
* 每个服务可以独立扩展，选择最适合的硬件

### 微服务的缺点
* 没有银弹，微服务本身概念模糊，多大算微，粒度该如何选择
* 分布式框架的使用使得整体变得复杂
* 分区数据库架构，更新不同服务的数据库会变得很麻烦，通常不会选择分布式事务，且不说不满足CAP定理，有些数据库
压根不支持事务，最终不得不使用基于最终一致性的方法。这对开发人员来说是个很大的挑战
* 微服务的测试也变得复杂，测试一个服务需要启动其他依赖的服务
* 跨越多服务的变更，需要仔细的规划协调出现的变更至每个服务
* 服务数量变多之后，服务的部署和管理变得困难
* 每个服务需要由多个运行实例，还有更过移动部件需要配置，部署，扩展和监控；还需要实现服务发现机制使得服务可以
知道需要通信的其他服务的位置
