# 微服务
## 微服务简介
### 构建单体应用模型
* 运用分层思想构建的应用程序，尽管有逻辑模块化架构，但是作为一个单体打包部署
* 如Java打包成war文件部署在tomcat或者是jetty之类的应用服务器上
* 这种方式的应用很常见，非常易于开发和测试，单体应用同样易于部署，自需要打包拷贝到服务器即可
* 还可以通过运行多个副本结合负载均衡器来扩展应用
* 在早期阶段，可以良好运作

### 走向单体地狱
* 单体应用有很大的局限性。项目随着时间的推移会变得越来越臃肿，小而简单的应用变成了庞大的单体，互相之间依赖错综复杂
* 单体应用过于复杂，可读性变差，修复bug和实现新功能变得非常困难而耗时
* 基本代码都难以理解，那么改变也不会变得正确，负反馈作用下，得到的将是一个巨大且不可思议的大泥球
* 服务越大，启动时间将越长，时间在等待中流失
* 在变更系统的时候，启动时间太长，而且变更产生的影响通常不明确，需要大量测试，因此持续部署几乎不可能
* 当不同模块存在资源需求冲突时，单体应用难以扩展（CPU密集和IO密集，必须一方做出妥协）
* 单体应用可靠性低，所有模块运行在同一进程中，任何一个模块的bug（如内存泄漏）会拖垮整个进程
* 单体应用使得采用新框架和语言变得困难
> 总结：一个成功的关键应用程序，已经发展成一个只有少数开发人员理解的巨大单体，它使用了过时，非生产性技术编写
，使得招聘变得困难，应用程序难以扩展，不可靠，因此敏捷开发和应用交付是不可能的。

### 微服务-解决复杂问题
* 将应用程序分解成一套较小的互连服务，一个服务通常实现了一组不同的特性或者功能。如订单管理，客户管理
* 一些微服务会暴露一个提供其他微服务或应用客户端消费的api，其他微服务可能实现了一个web UI，运行时，每个实例
通常是一个云虚拟主机或一个docker容器
* 将Web应用程序划分成了一组更简单的web应用程序
* 应用不能直接访问后端服务，应通过API网关通信，API网关负责负载均衡，缓存，访问控制，API计量和监控（如Nginx）
* 每个服务实例是一个docker容器，为了实现高可用，容器在多个虚拟机上运行
* 微服务的架构影响到了应用程序和数据库之间的关系
** 每一服务都应该有自己的数据库模式
** 这样做与企业级数据库数据模型的思想相背，且会造成数据冗余
** 但利大于弊，能够实现松耦合，且可以选用最适合应用的数据库
* 看起来微服务架构类似SOA（面向服务架构）

### 微服务的优点
* 解决了复杂的问题，强制一定程度的模块化，使得个体服务能被更快的开发，并更容易理解与维护
* 每个服务都可以由一个团队专注开发，可自由进行技术选型使用新技术，而且服务较小，用新技术重写旧服务变得可行
* 每个微服务独立部署，不需要协调部署本地变更到服务，使得持续部署成为可能
* 每个服务可以独立扩展，选择最适合的硬件

### 微服务的缺点
* 没有银弹，微服务本身概念模糊，多大算微，粒度该如何选择
* 分布式框架的使用使得整体变得复杂
* 分区数据库架构，更新不同服务的数据库会变得很麻烦，通常不会选择分布式事务，且不说不满足CAP定理，有些数据库
压根不支持事务，最终不得不使用基于最终一致性的方法。这对开发人员来说是个很大的挑战
* 微服务的测试也变得复杂，测试一个服务需要启动其他依赖的服务
* 跨越多服务的变更，需要仔细的规划协调出现的变更至每个服务
* 服务数量变多之后，服务的部署和管理变得困难
* 每个服务需要由多个运行实例，还有更过移动部件需要配置，部署，扩展和监控；还需要实现服务发现机制使得服务可以
知道需要通信的其他服务的位置

## 微服务的最佳实践
* 微服务必须解决的四个问题
    ** 客户端如何访问这些服务
    ** 每个服务之间如何通信
    ** 如此多的服务如何实现(服务治理)
    ** 服务挂了该如何解决

### 客户端如何访问这些服务
* 单体应用时可以直接通过UI调用，但是服务独立在不同进程，UI应该何如访问
* 后台由n各服务，前台就需要记住管理n个服务，一个服务下线升级，前台就需要重新部署
* 服务间通信存在网络开销，服务通常无状态，如登录信息和权限管理等需要有一个统一的地方维护管理（OAuth）
* 所以在API和UI之间一般会有一个代理，叫API Gateway，作用包括
    ** 提供统一服务入口，让微服务对前台透明
    ** 聚合后台服务，节省流量，提升性能
    ** 提供安全，过滤，流控等API管理功能
* `API Gateway`有很多广义的实现方法，可以时一个简单的mvc或者是Node.js的服务端。但是`API Gateway`也可能成为
单点故障点或者是性能瓶颈

### 每个服务之间如何通信
* 所有微服务都跑在独立的Java进程虚拟机中，所以服务间通信就是IPC，已经有很多成熟的方案
* 同步调用
    ** REST（JAX-RS，spring boot）
    ** RPC（Thrift，dubbo）
    ** 同步调用比较简单，一致性强，但容易出调用问题，性能体验上也会差一些，特别是调用层次多的时候
    ** REST基于HTTP更容易实现，使用较为灵活，各种语言都支持，对客户端无特殊要求
    ** RPC协议更高效，安全可控，特别是在有统一开发规范和服务框架的公司内部，开发优势更明显
* 异步调用
        ** Kafka
        ** Notify
        ** MessageQueue
        ** 以部调用在分布式系统中使用异常广泛，既能解耦，又能成为调用之间的缓冲，确保消息积压不会冲垮被调用方
        同时保证调用方的服务体验，继续干自己的活，不会被后台性能拖慢
        ** 付出的代价是一致性减弱，需要接收数据的最终一致性，还有就是后台服务一般要实现幂等性，因为消息送出于性能
        考虑一般会有重复（保证消息的收到且只收到一次对性能是很大的考验），最后就是必须引入一个Broker

### 如此多的服务如何实现
每个服务都有多个拷贝做负载均衡，一个服务随时可能下线，也可能增加新的节点，服务间如何互相感知，服务如何管理
这就是服务发现的问题，一般有两种做法，基本都是通过zookeeper等类似技术做服务注册消息的分布式管理。服务上线
提供者将其注册到zk，并通过心跳维持长连接，实时更新连接信息。服务调用者通过zk寻址，根据定制算法找到对应服务
还可以将服务消息缓存本地以提高性能，服务下线时zk通知服务客户端

* 基于客户端的服务注册与发现
    ** 优点是架构简单扩展灵活，只对服务注册依赖。缺点是客户端要维护所有调用服务的地址，有技术难度比如dubbo
* 服务端的服务注册与发现
    ** 有点是简单，所有服务对前台调用方透明，一般小公司在云服务上部署的应用采用比较多

### 服务挂了该如何解决（备份方案，应急处理机制）
单体应用开发的风险在于一荣俱荣，一损俱损。而分布式最大的特性是网络不可靠。所以当我们系统是由一系列的微服务
调用链组成的时候，必须确保任一环节出问题不会影响整体链路。相应的手段有很多：
* 重试机制
* 限流
* 熔断机制
* 负载均衡
* 降级（本地缓存）

## 几大解决方案
### Spring Cloud Netflix
* API网关，Zuul组件
* 服务注册与发现 Eureka
* Feign -> http client -> http通信，同步并阻塞
* 熔断机制，Hystrix

### Apache Dubbo Zookeeper
* Dubbo是一个高性能的Java RPC通信框架
* 服务注册与发现使用，Zookeeper
* API网关，没有，第三方或者自己实现
* 服务挂啦使用 Hystrix

### Spring Cloud Alibaba
* https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/README-zh.md

## 其他
### 分布式锁

* 场景：三个并发，三个人买两本笔记本，同时下三个订单。如何保证数据一致性？
单机下可以用并发的API，但是分布式情况下就变得复杂

* 分布式锁具备的条件
    ** 在分布式环境下，一个方法在同一个时间只能被一个机器的一个线程执行
    ** 高可用的获取锁和释放锁
    ** 高性能的获取锁和释放锁
    ** 具备可重入性
    ** 具备锁失效机制，防止死锁
    ** 具备非阻塞锁特性，没有获取到锁将直接返回获取锁失败

一般使用三台服务以主从模式提供服务，当master节点挂了之后，整个服务就挂了，这时候成为单点故障
为了解决这个问题，一般加上一个备用的master节点，向主节点发送心跳维持连接，一旦发现master挂了就升级为master
但是这样做容易出现一个问题：就是如果网络丢包了，备用以为master挂了，启用为master这时就有了两个master，整个
服务就乱套了。此时引入zookerper来解决这个问题
### Zookeeper解决方案
* Master启动
    ** 启动两个主节点，注册后进行选举，选举成功的节点获得锁成为主节点，另一个成为备用节点
* Master故障
    ** 如果此时主节点A挂了，则从注册中心删除，Zookeeper会自动感知变化，再次选举，将B升级为主节点
* Master恢复
    ** 重新到注册中心注册，成为C节点，再次选举仍只有一个主节点提供服务

### 什么是Zookeeper
为分布式应用提供一致性服务的开源组件，内部是一个分层的文件系统目录树，规定统一目录只能有一个唯一文件名

* Zookeeper实现分布式锁的步骤
    1. 创建一个目录myZookeeper
    2. 线程A想获取锁就在目录下创建一个临时顺序节点
    3. 获取目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程最小，获得锁
    4. 线程B获取所有节点，判断自己不是最小的节点，设置监听比自己次小的节点
    5. 线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小节点，如果是则获得锁
